import { ExternalLoaderBody, ExternalLoaderHeaders, ExternalLoaderInterface, ExternalLoaderParams } from "../../ExternalLoader";
import { ErrorCallback, GeocodedResultsCallback, ProviderInterface, ProviderOptionsInterface, YandexGeocoded, YandexGeocodeQuery, YandexGeocodeQueryObject, YandexReverseQuery, YandexReverseQueryObject } from "./..";
export declare type YandexKind = "house" | "street" | "metro" | "district" | "locality" | "area" | "province" | "country" | "region" | "hydro" | "railway_station" | "station" | "route" | "vegetation" | "airport" | "entrance" | "other";
export declare type YandexPrecision = "exact" | "number" | "near" | "range" | "street" | "other";
export interface YandexResult {
    metaDataProperty: {
        GeocoderMetaData: {
            kind: YandexKind;
            text: string;
            precision: YandexPrecision;
            AddressDetails: {
                Country: {
                    AddressLine: string;
                    CountryNameCode: string;
                    CountryName: string;
                    AdministrativeArea?: {
                        AdministrativeAreaName: string;
                        SubAdministrativeArea?: {
                            SubAdministrativeAreaName: string;
                            Locality?: {
                                LocalityName: string;
                                Thoroughfare?: {
                                    ThoroughfareName: string;
                                    Premise: {
                                        PremiseNumber: string;
                                    };
                                };
                            };
                        };
                    };
                };
            };
        };
    };
    description: string;
    name: string;
    boundedBy: {
        Envelope: {
            lowerCorner: string;
            upperCorner: string;
        };
    };
    Point: {
        pos: string;
    };
}
export interface YandexResponse {
    response: {
        GeoObjectCollection: {
            metaDataProperty: {
                GeocoderResponseMetaData: {
                    request: string;
                    suggest?: {
                        fix: string;
                    };
                    found: string;
                    results: string;
                    skip: string;
                };
            };
            featureMember: {
                GeoObject: YandexResult;
            }[];
        };
    };
}
export interface YandexProviderOptionsInterface extends ProviderOptionsInterface {
    readonly apiKey: string;
}
export declare const defaultYandexProviderOptions: {
    apiKey: string;
    useSsl?: boolean | undefined;
    useJsonp?: boolean | undefined;
};
declare type YandexGeocodedResultsCallback = GeocodedResultsCallback<YandexGeocoded>;
export default class YandexProvider implements ProviderInterface<YandexGeocoded> {
    private externalLoader;
    private options;
    constructor(_externalLoader: ExternalLoaderInterface, options?: YandexProviderOptionsInterface);
    geocode(query: string | YandexGeocodeQuery | YandexGeocodeQueryObject, callback?: YandexGeocodedResultsCallback, errorCallback?: ErrorCallback): void | Promise<YandexGeocoded[]>;
    geodecode(latitudeOrQuery: number | string | YandexReverseQuery | YandexReverseQueryObject, longitudeOrCallback?: number | string | YandexGeocodedResultsCallback, callbackOrErrorCallback?: YandexGeocodedResultsCallback | ErrorCallback, errorCallback?: ErrorCallback): void | Promise<YandexGeocoded[]>;
    private withCommonParams;
    executeRequest(params: ExternalLoaderParams, callback: YandexGeocodedResultsCallback, headers?: ExternalLoaderHeaders, body?: ExternalLoaderBody, errorCallback?: ErrorCallback): void;
    static mapToGeocoded(result: YandexResult): YandexGeocoded;
}
export {};
//# sourceMappingURL=YandexProvider.d.ts.map