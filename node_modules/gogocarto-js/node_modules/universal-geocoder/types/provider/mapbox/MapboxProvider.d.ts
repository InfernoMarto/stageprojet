import { ExternalLoaderBody, ExternalLoaderHeaders, ExternalLoaderInterface, ExternalLoaderParams } from "../../ExternalLoader";
import { ErrorCallback, GeocodedResultsCallback, MapboxGeocoded, MapboxGeocodeQuery, MapboxGeocodeQueryObject, MapboxReverseQuery, MapboxReverseQueryObject, ProviderInterface, ProviderOptionsInterface } from "./..";
import { FlatBoundingBox, FlatCoordinates } from "../../types";
interface MapboxFeatureContextProperties {
    id: string;
    text: string;
    wikidata?: string;
    short_code?: string;
}
interface MapboxFeatureProperties {
    accuracy?: string;
    address?: string;
    category?: string;
    maki?: string;
    wikidata?: string;
    short_code?: string;
}
export interface MapboxResult {
    id: string;
    type: "Feature";
    place_type: ("country" | "region" | "postcode" | "district" | "place" | "locality" | "neighborhood" | "address" | "poi")[];
    relevance: number;
    address?: string;
    properties: MapboxFeatureProperties;
    text: string;
    place_name: string;
    matching_text?: string;
    matching_place_name?: string;
    language?: string;
    bbox?: FlatBoundingBox;
    center: FlatCoordinates;
    geometry: {
        type: "Point";
        coordinates: FlatCoordinates;
    };
    context?: MapboxFeatureContextProperties[];
    routable_points?: {
        points?: {
            coordinates: FlatCoordinates;
        }[];
    };
}
export interface MapboxResponse {
    type: "FeatureCollection";
    query: string[];
    features: MapboxResult[];
    attribution: string;
}
export declare enum MAPBOX_SOURCES {
    SOURCE_PLACES = "mapbox.places",
    SOURCE_PLACES_PERMANENT = "mapbox.places-permanent"
}
export interface MapboxProviderOptionsInterface extends ProviderOptionsInterface {
    readonly apiKey: string;
    readonly source?: MAPBOX_SOURCES;
    readonly countryCodes?: string[];
}
export declare const defaultMapboxProviderOptions: {
    apiKey: string;
    source: MAPBOX_SOURCES;
    useSsl?: boolean | undefined;
    useJsonp?: boolean | undefined;
};
declare type MapboxGeocodedResultsCallback = GeocodedResultsCallback<MapboxGeocoded>;
export default class MapboxProvider implements ProviderInterface<MapboxGeocoded> {
    private externalLoader;
    private options;
    constructor(_externalLoader: ExternalLoaderInterface, options?: MapboxProviderOptionsInterface);
    geocode(query: string | MapboxGeocodeQuery | MapboxGeocodeQueryObject, callback?: MapboxGeocodedResultsCallback, errorCallback?: ErrorCallback): void | Promise<MapboxGeocoded[]>;
    geodecode(latitudeOrQuery: number | string | MapboxReverseQuery | MapboxReverseQueryObject, longitudeOrCallback?: number | string | MapboxGeocodedResultsCallback, callbackOrErrorCallback?: MapboxGeocodedResultsCallback | ErrorCallback, errorCallback?: ErrorCallback): void | Promise<MapboxGeocoded[]>;
    private withCommonParams;
    executeRequest(params: ExternalLoaderParams, callback: MapboxGeocodedResultsCallback, headers?: ExternalLoaderHeaders, body?: ExternalLoaderBody, errorCallback?: ErrorCallback): void;
    static mapToGeocoded(result: MapboxResult): MapboxGeocoded;
}
export {};
//# sourceMappingURL=MapboxProvider.d.ts.map