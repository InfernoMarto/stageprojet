import { ExternalLoaderBody, ExternalLoaderHeaders, ExternalLoaderInterface, ExternalLoaderParams } from "../../ExternalLoader";
import { ErrorCallback, GeocodedResultsCallback, LocationIQGeocoded, LocationIQGeocodeQuery, LocationIQGeocodeQueryObject, LocationIQReverseQuery, LocationIQReverseQueryObject, ProviderInterface, ProviderOptionsInterface } from "./..";
interface LocationIQErrorResponse {
    error: string;
}
export declare type LocationIQOsmType = "node" | "way" | "relation";
export declare type LocationIQPrecision = "venue" | "building" | "street" | "neighbourhood" | "island" | "borough" | "city" | "county" | "state" | "country" | "marine" | "postalcode";
export declare type LocationIQPrecisionCode = "exact" | "fallback" | "approximate";
export declare type LocationIQPrecisionType = "point" | "centroid" | "interpolated";
export interface LocationIQResult {
    place_id: string;
    licence: string;
    osm_type: LocationIQOsmType;
    osm_id: string;
    boundingbox: [string, string, string, string];
    lat: string;
    lon: string;
    display_name: string;
    class?: string;
    type?: string;
    importance: number;
    icon: string;
    address: {
        house_number?: string;
        road?: string;
        neighbourhood?: string;
        hamlet?: string;
        suburb?: string;
        village?: string;
        town?: string;
        city_district?: string;
        city?: string;
        region?: string;
        county?: string;
        state_district?: string;
        state?: string;
        state_code?: string;
        postcode?: string;
        country?: string;
        country_code?: string;
        name?: string;
    };
    extratags?: {
        phone?: string;
        website?: string;
        wikidata?: string;
        wikipedia?: string;
        wheelchair?: string;
        opening_hours?: string;
    };
    namedetails?: {
        name: string;
        [name: string]: string;
    };
    geojson?: {
        type: "Point";
        coordinates: [number, number];
    };
    geokml?: string;
    svg?: string;
    geotext?: string;
    statecode?: string;
    distance?: number;
    matchquality?: {
        matchcode: LocationIQPrecisionCode;
        matchtype: LocationIQPrecisionType;
        matchlevel: LocationIQPrecision;
    };
    postal_address?: string;
}
export declare type LocationIQResponse = LocationIQErrorResponse | LocationIQResult | LocationIQResult[];
export interface LocationIQProviderOptionsInterface extends ProviderOptionsInterface {
    readonly apiKey: string;
    readonly countryCodes?: string[];
    readonly source?: "nominatim" | "locationiq";
}
export declare const defaultLocationIQProviderOptions: LocationIQProviderOptionsInterface;
declare type LocationIQGeocodedResultsCallback = GeocodedResultsCallback<LocationIQGeocoded>;
export default class LocationIQProvider implements ProviderInterface<LocationIQGeocoded> {
    private externalLoader;
    private options;
    constructor(_externalLoader: ExternalLoaderInterface, options?: LocationIQProviderOptionsInterface);
    geocode(query: string | LocationIQGeocodeQuery | LocationIQGeocodeQueryObject, callback?: LocationIQGeocodedResultsCallback, errorCallback?: ErrorCallback): void | Promise<LocationIQGeocoded[]>;
    geodecode(latitudeOrQuery: number | string | LocationIQReverseQuery | LocationIQReverseQueryObject, longitudeOrCallback?: number | string | LocationIQGeocodedResultsCallback, callbackOrErrorCallback?: LocationIQGeocodedResultsCallback | ErrorCallback, errorCallback?: ErrorCallback): void | Promise<LocationIQGeocoded[]>;
    private withCommonParams;
    executeRequest(params: ExternalLoaderParams, callback: LocationIQGeocodedResultsCallback, headers?: ExternalLoaderHeaders, body?: ExternalLoaderBody, errorCallback?: ErrorCallback): void;
    static mapToGeocoded(result: LocationIQResult): LocationIQGeocoded;
}
export {};
//# sourceMappingURL=LocationIQProvider.d.ts.map