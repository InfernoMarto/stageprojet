var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var GeoJsonDumper = /** @class */ (function () {
    function GeoJsonDumper() {
    }
    GeoJsonDumper.dump = function (geocoded) {
        var result = GeoJsonDumper.baseGeoJson;
        var _a = geocoded.toObject(), coordinates = _a.coordinates, bounds = _a.bounds, adminLevels = _a.adminLevels, geocodedProperties = __rest(_a, ["coordinates", "bounds", "adminLevels"]);
        var properties = __assign({}, geocodedProperties);
        Object.keys(properties).forEach(function (property) {
            return properties[property] === undefined && delete properties[property];
        });
        if (adminLevels && adminLevels.length > 0) {
            properties = __assign(__assign({}, properties), { adminLevels: adminLevels.map(function (adminLevel) { return adminLevel.toObject(); }) });
        }
        result = __assign(__assign({}, result), { properties: properties });
        if (coordinates) {
            result = __assign(__assign({}, result), {
                geometry: __assign(__assign({}, result.geometry), { type: "Point", coordinates: [
                        parseFloat(coordinates.longitude.toString()),
                        parseFloat(coordinates.latitude.toString()),
                    ] }),
            });
        }
        if (bounds) {
            result = __assign(__assign({}, result), { bbox: [
                    parseFloat(bounds.longitudeSW.toString()),
                    parseFloat(bounds.latitudeSW.toString()),
                    parseFloat(bounds.longitudeNE.toString()),
                    parseFloat(bounds.latitudeNE.toString()),
                ] });
        }
        return result;
    };
    GeoJsonDumper.baseGeoJson = {
        type: "Feature",
        properties: {},
        geometry: {
            type: "Point",
            coordinates: [0, 0],
        },
    };
    return GeoJsonDumper;
}());
export default GeoJsonDumper;
//# sourceMappingURL=GeoJsonDumper.js.map