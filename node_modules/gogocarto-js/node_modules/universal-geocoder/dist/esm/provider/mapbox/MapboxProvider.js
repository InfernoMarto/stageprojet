var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { MapboxGeocoded, MapboxGeocodeQuery, MapboxReverseQuery, ProviderHelpers, defaultProviderOptions, } from "./..";
import AdminLevel, { ADMIN_LEVEL_CODES } from "../../AdminLevel";
// eslint-disable-next-line no-shadow
export var MAPBOX_SOURCES;
(function (MAPBOX_SOURCES) {
    MAPBOX_SOURCES["SOURCE_PLACES"] = "mapbox.places";
    MAPBOX_SOURCES["SOURCE_PLACES_PERMANENT"] = "mapbox.places-permanent";
})(MAPBOX_SOURCES || (MAPBOX_SOURCES = {}));
export var defaultMapboxProviderOptions = __assign(__assign({}, defaultProviderOptions), { apiKey: "", source: MAPBOX_SOURCES.SOURCE_PLACES });
var MapboxProvider = /** @class */ (function () {
    function MapboxProvider(_externalLoader, options) {
        if (options === void 0) { options = defaultMapboxProviderOptions; }
        this.externalLoader = _externalLoader;
        this.options = __assign(__assign({}, defaultMapboxProviderOptions), options);
        if (!this.options.apiKey) {
            throw new Error('An API key is required for the Mapbox provider. Please add it in the "apiKey" option.');
        }
        if (![
            MAPBOX_SOURCES.SOURCE_PLACES,
            MAPBOX_SOURCES.SOURCE_PLACES_PERMANENT,
        ].includes(this.options.source || "")) {
            throw new Error("The \"source\" option must either be \"" + MAPBOX_SOURCES.SOURCE_PLACES + "\" or \"" + MAPBOX_SOURCES.SOURCE_PLACES_PERMANENT + "\".");
        }
    }
    MapboxProvider.prototype.geocode = function (query, callback, errorCallback) {
        var _this = this;
        var _a, _b, _c, _d, _e, _f, _g;
        var geocodeQuery = ProviderHelpers.getGeocodeQueryFromParameter(query, MapboxGeocodeQuery);
        if (geocodeQuery.getIp()) {
            throw new Error("The Mapbox provider does not support IP geolocation, only location geocoding.");
        }
        this.externalLoader.setOptions({
            protocol: this.options.useSsl ? "https" : "http",
            host: "api.mapbox.com",
            pathname: "geocoding/v5/" + this.options.source + "/" + geocodeQuery.getText() + ".json",
        });
        var fuzzyMatch = geocodeQuery.getFuzzyMatch()
            ? "true"
            : "false";
        var params = this.withCommonParams({
            bbox: geocodeQuery.getBounds()
                ? ((_a = geocodeQuery.getBounds()) === null || _a === void 0 ? void 0 : _a.longitudeSW) + "," + ((_b = geocodeQuery.getBounds()) === null || _b === void 0 ? void 0 : _b.latitudeSW) + "," + ((_c = geocodeQuery.getBounds()) === null || _c === void 0 ? void 0 : _c.longitudeNE) + "," + ((_d = geocodeQuery.getBounds()) === null || _d === void 0 ? void 0 : _d.latitudeNE)
                : undefined,
            fuzzyMatch: geocodeQuery.getFuzzyMatch() !== undefined
                ? fuzzyMatch
                : undefined,
            proximity: geocodeQuery.getProximity()
                ? ((_e = geocodeQuery.getProximity()) === null || _e === void 0 ? void 0 : _e.longitude) + "," + ((_f = geocodeQuery.getProximity()) === null || _f === void 0 ? void 0 : _f.latitude)
                : undefined,
            types: geocodeQuery.getTypes()
                ? (_g = geocodeQuery.getTypes()) === null || _g === void 0 ? void 0 : _g.join(",")
                : undefined,
        }, geocodeQuery);
        if (!callback) {
            return new Promise(function (resolve, reject) {
                return _this.executeRequest(params, function (results) { return resolve(results); }, {}, {}, function (error) { return reject(error); });
            });
        }
        return this.executeRequest(params, callback, {}, {}, errorCallback);
    };
    MapboxProvider.prototype.geodecode = function (latitudeOrQuery, longitudeOrCallback, callbackOrErrorCallback, errorCallback) {
        var _this = this;
        var _a;
        var reverseQuery = ProviderHelpers.getReverseQueryFromParameters(latitudeOrQuery, longitudeOrCallback, MapboxReverseQuery);
        var reverseCallback = ProviderHelpers.getCallbackFromParameters(longitudeOrCallback, callbackOrErrorCallback);
        var reverseErrorCallback = ProviderHelpers.getErrorCallbackFromParameters(longitudeOrCallback, callbackOrErrorCallback, errorCallback);
        this.externalLoader.setOptions({
            protocol: this.options.useSsl ? "https" : "http",
            host: "api.mapbox.com",
            pathname: "geocoding/v5/" + this.options.source + "/" + reverseQuery.getCoordinates().longitude + "," + reverseQuery.getCoordinates().latitude + ".json",
        });
        var params = this.withCommonParams({
            reverseMode: reverseQuery.getReverseMode()
                ? reverseQuery.getReverseMode()
                : undefined,
            types: reverseQuery.getTypes()
                ? (_a = reverseQuery.getTypes()) === null || _a === void 0 ? void 0 : _a.join(",")
                : "address",
        }, reverseQuery);
        if (!reverseCallback) {
            return new Promise(function (resolve, reject) {
                return _this.executeRequest(params, function (results) { return resolve(results); }, {}, {}, function (error) { return reject(error); });
            });
        }
        return this.executeRequest(params, reverseCallback, {}, {}, reverseErrorCallback);
    };
    MapboxProvider.prototype.withCommonParams = function (params, query) {
        var _a, _b;
        return __assign(__assign({}, params), { access_token: this.options.apiKey || "", country: query.getCountryCodes()
                ? (_a = query.getCountryCodes()) === null || _a === void 0 ? void 0 : _a.join(",")
                : (_b = this.options.countryCodes) === null || _b === void 0 ? void 0 : _b.join(","), language: query.getLocale(), limit: query.getLimit().toString() });
    };
    MapboxProvider.prototype.executeRequest = function (params, callback, headers, body, errorCallback) {
        this.externalLoader.executeRequest(params, function (data) {
            callback(data.features.map(function (result) {
                return MapboxProvider.mapToGeocoded(result);
            }));
        }, headers, body, errorCallback);
    };
    MapboxProvider.mapToGeocoded = function (result) {
        var latitude = result.geometry.coordinates[1];
        var longitude = result.geometry.coordinates[0];
        var formattedAddress = result.place_name;
        var streetNumber = result.address;
        var streetName = result.text;
        var locality;
        var postalCode;
        var region;
        var country;
        var countryCode;
        var adminLevels = [];
        var types = result.place_type;
        var adminLevelCode;
        (result.context || []).forEach(function (feature) {
            var type = feature.id.split(".")[0];
            switch (type) {
                case "locality":
                    locality = feature.text;
                    break;
                case "place":
                    locality = feature.text;
                    adminLevels.push(AdminLevel.create({
                        level: ADMIN_LEVEL_CODES.COUNTY_CODE,
                        name: locality,
                    }));
                    break;
                case "postcode":
                    postalCode = feature.text;
                    break;
                case "region":
                    region = feature.text;
                    adminLevelCode = undefined;
                    if (feature.short_code && feature.short_code.match(/[A-z]{2}-/)) {
                        adminLevelCode = feature.short_code.replace(/[A-z]{2}-/, "");
                    }
                    adminLevels.push(AdminLevel.create({
                        level: ADMIN_LEVEL_CODES.STATE_CODE,
                        name: region,
                        code: adminLevelCode,
                    }));
                    break;
                case "country":
                    country = feature.text;
                    countryCode = feature.short_code;
                    break;
                default:
            }
        });
        var geocoded = MapboxGeocoded.create({
            coordinates: {
                latitude: latitude,
                longitude: longitude,
            },
            formattedAddress: formattedAddress,
            streetNumber: streetNumber,
            streetName: streetName,
            locality: locality,
            postalCode: postalCode,
            region: region,
            adminLevels: adminLevels,
            country: country,
            countryCode: countryCode,
            types: types,
        });
        if (result.bbox) {
            geocoded = geocoded.withBounds({
                latitudeSW: result.bbox[1],
                longitudeSW: result.bbox[0],
                latitudeNE: result.bbox[3],
                longitudeNE: result.bbox[2],
            });
        }
        return geocoded;
    };
    return MapboxProvider;
}());
export default MapboxProvider;
//# sourceMappingURL=MapboxProvider.js.map