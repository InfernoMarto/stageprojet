"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultOpenCageProviderOptions = void 0;
var provider_1 = require("./..");
var AdminLevel_1 = __importDefault(require("../../AdminLevel"));
var error_1 = require("../../error");
exports.defaultOpenCageProviderOptions = __assign(__assign({}, provider_1.defaultProviderOptions), { apiKey: "" });
var OpenCageProvider = /** @class */ (function () {
    function OpenCageProvider(_externalLoader, options) {
        if (options === void 0) { options = exports.defaultOpenCageProviderOptions; }
        this.externalLoader = _externalLoader;
        this.options = __assign(__assign({}, exports.defaultOpenCageProviderOptions), options);
        if (!this.options.apiKey) {
            throw new Error('An API key is required for the OpenCage provider. Please add it in the "apiKey" option.');
        }
    }
    OpenCageProvider.prototype.geocode = function (query, callback, errorCallback) {
        var _a, _b, _c, _d, _e, _f;
        var geocodeQuery = provider_1.ProviderHelpers.getGeocodeQueryFromParameter(query, provider_1.OpenCageGeocodeQuery);
        if (geocodeQuery.getIp()) {
            throw new Error("The OpenCage provider does not support IP geolocation, only location geocoding.");
        }
        this.externalLoader.setOptions({
            protocol: this.options.useSsl ? "https" : "http",
            host: "api.opencagedata.com",
            pathname: "geocode/v1/json",
        });
        var params = this.withCommonParams({
            q: geocodeQuery.getText() || "",
            bounds: geocodeQuery.getBounds()
                ? ((_a = geocodeQuery.getBounds()) === null || _a === void 0 ? void 0 : _a.west) + "," + ((_b = geocodeQuery.getBounds()) === null || _b === void 0 ? void 0 : _b.south) + "," + ((_c = geocodeQuery.getBounds()) === null || _c === void 0 ? void 0 : _c.east) + "," + ((_d = geocodeQuery.getBounds()) === null || _d === void 0 ? void 0 : _d.north)
                : undefined,
            proximity: geocodeQuery.getProximity()
                ? ((_e = geocodeQuery.getProximity()) === null || _e === void 0 ? void 0 : _e.latitude) + "," + ((_f = geocodeQuery.getProximity()) === null || _f === void 0 ? void 0 : _f.longitude)
                : undefined,
        }, geocodeQuery);
        this.executeRequest(params, callback, {}, {}, errorCallback);
    };
    OpenCageProvider.prototype.geodecode = function (latitudeOrQuery, longitudeOrCallback, callbackOrErrorCallback, errorCallback) {
        var reverseQuery = provider_1.ProviderHelpers.getReverseQueryFromParameters(latitudeOrQuery, longitudeOrCallback, provider_1.OpenCageReverseQuery);
        var reverseCallback = provider_1.ProviderHelpers.getCallbackFromParameters(longitudeOrCallback, callbackOrErrorCallback);
        var reverseErrorCallback = provider_1.ProviderHelpers.getErrorCallbackFromParameters(longitudeOrCallback, callbackOrErrorCallback, errorCallback);
        this.externalLoader.setOptions({
            protocol: this.options.useSsl ? "https" : "http",
            host: "api.opencagedata.com",
            pathname: "geocode/v1/json",
        });
        var params = this.withCommonParams({
            q: reverseQuery.getCoordinates().latitude + "," + reverseQuery.getCoordinates().longitude,
        }, reverseQuery);
        this.executeRequest(params, reverseCallback, {}, {}, reverseErrorCallback);
    };
    OpenCageProvider.prototype.withCommonParams = function (params, query) {
        var _a, _b, _c, _d;
        return __assign(__assign({}, params), { key: this.options.apiKey || "", countrycode: query.getCountryCodes()
                ? (_a = query.getCountryCodes()) === null || _a === void 0 ? void 0 : _a.join(",") : (_b = this.options.countryCodes) === null || _b === void 0 ? void 0 : _b.join(","), language: query.getLocale(), limit: query.getLimit().toString(), min_confidence: (_c = query.getMinConfidence()) === null || _c === void 0 ? void 0 : _c.toString(), no_record: (_d = query.getNoRecord()) === null || _d === void 0 ? void 0 : _d.toString(), jsonpCallback: this.options.useJsonp ? "jsonp" : undefined });
    };
    OpenCageProvider.prototype.executeRequest = function (params, callback, headers, body, errorCallback) {
        this.externalLoader.executeRequest(params, function (data) {
            callback(data.results.map(function (result) {
                return OpenCageProvider.mapToGeocoded(result);
            }));
        }, headers, body, function (error) {
            var response = error.getResponse();
            response.json().then(function (data) {
                if (data.status) {
                    var errorMessage_1;
                    switch (data.status.code) {
                        case 400:
                            errorMessage_1 = "Invalid request (400): " + data.status.message;
                            break;
                        case 401:
                            errorMessage_1 = "Unable to authenticate (401): " + data.status.message;
                            break;
                        case 402:
                            errorMessage_1 = "Quota exceeded (402): " + data.status.message;
                            break;
                        case 403:
                            errorMessage_1 = "Forbidden (403): " + data.status.message;
                            break;
                        case 404:
                            errorMessage_1 = "Invalid API endpoint (404): " + data.status.message;
                            break;
                        case 405:
                            errorMessage_1 = "Method not allowed (405): " + data.status.message;
                            break;
                        case 408:
                            errorMessage_1 = "Timeout (408): " + data.status.message;
                            break;
                        case 410:
                            errorMessage_1 = "Request too long (410): " + data.status.message;
                            break;
                        case 429:
                            errorMessage_1 = "Too many requests (429): " + data.status.message;
                            break;
                        case 503:
                            errorMessage_1 = "Internal server error (503): " + data.status.message;
                            break;
                        default:
                            errorMessage_1 = "Error (" + data.status.code + "): " + data.status.message;
                    }
                    if (errorCallback) {
                        errorCallback(new error_1.ResponseError(errorMessage_1, data));
                        return;
                    }
                    setTimeout(function () {
                        throw new Error(errorMessage_1);
                    });
                }
            });
        });
    };
    OpenCageProvider.mapToGeocoded = function (result) {
        var _a;
        var latitude = result.geometry.lat;
        var longitude = result.geometry.lng;
        var formattedAddress = result.formatted;
        var streetNumber = result.components.house_number;
        var postalCode = result.components.postcode;
        var region = result.components.state;
        var country = result.components.country;
        var countryCode = result.components.country_code;
        var timezone = result.annotations.timezone.name;
        var callingCode = result.annotations.callingcode;
        var flag = result.annotations.flag;
        var mgrs = result.annotations.MGRS;
        var maidenhead = result.annotations.Maidenhead;
        var geohash = result.annotations.geohash;
        var what3words = (_a = result.annotations.what3words) === null || _a === void 0 ? void 0 : _a.words;
        var streetName = result.components.road ||
            result.components.footway ||
            result.components.street ||
            result.components.street_name ||
            result.components.residential ||
            result.components.path ||
            result.components.pedestrian ||
            result.components.road_reference ||
            result.components.road_reference_intl;
        var subLocality = result.components.neighbourhood ||
            result.components.suburb ||
            result.components.city_district ||
            result.components.district ||
            result.components.quarter ||
            result.components.houses ||
            result.components.subdivision;
        var locality = result.components.city ||
            result.components.town ||
            result.components.municipality ||
            result.components.village ||
            result.components.hamlet ||
            result.components.locality ||
            result.components.croft;
        var geocoded = provider_1.OpenCageGeocoded.create({
            latitude: latitude,
            longitude: longitude,
            formattedAddress: formattedAddress,
            streetNumber: streetNumber,
            streetName: streetName,
            subLocality: subLocality,
            locality: locality,
            postalCode: postalCode,
            region: region,
            country: country,
            countryCode: countryCode,
            timezone: timezone,
            callingCode: callingCode,
            flag: flag,
            mgrs: mgrs,
            maidenhead: maidenhead,
            geohash: geohash,
            what3words: what3words,
        });
        if (result.bounds) {
            geocoded = (geocoded.withBounds(result.bounds.southwest.lat, result.bounds.southwest.lng, result.bounds.northeast.lat, result.bounds.northeast.lng));
        }
        var adminLevels = [
            { nameKey: "state", codeKey: "state_code" },
            { nameKey: "county", codeKey: "county_code" },
        ];
        adminLevels.forEach(function (_a, level) {
            var nameKey = _a.nameKey, codeKey = _a.codeKey;
            if (result.components[nameKey]) {
                geocoded.addAdminLevel(AdminLevel_1.default.create({
                    level: level + 1,
                    name: result.components[nameKey] || "",
                    code: result.components[codeKey] || undefined,
                }));
            }
        });
        return geocoded;
    };
    return OpenCageProvider;
}());
exports.default = OpenCageProvider;
//# sourceMappingURL=OpenCageProvider.js.map